"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[108],{6159:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"v2","title":"Migrating from v1 to v2","description":"In version 1, @kafkajs/confluent-schema-registry only supported Avro schemas and","source":"@site/../docs/v2.md","sourceDirName":".","slug":"/v2","permalink":"/confluent-schema-registry/docs/v2","draft":false,"unlisted":false,"editUrl":"https://github.com/kafkajs/confluent-schema-registry/edit/master/s/../docs/v2.md","tags":[],"version":"current","frontMatter":{"id":"v2","title":"Migrating from v1 to v2","sidebar_label":"Migrating to version 2"},"sidebar":"docs","previous":{"title":"Example Avro Schemas","permalink":"/confluent-schema-registry/docs/schemas"},"next":{"title":"Development","permalink":"/confluent-schema-registry/docs/development"}}');var t=s(4848),r=s(8453);const c={id:"v2",title:"Migrating from v1 to v2",sidebar_label:"Migrating to version 2"},i=void 0,o={},h=[{value:"Adapting to new APIs",id:"adapting-to-new-apis",level:2},{value:"Configuring serialization libraries",id:"configuring-serialization-libraries",level:3},{value:"Registering schemas",id:"registering-schemas",level:3},{value:"Getting registry id by schema",id:"getting-registry-id-by-schema",level:3}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["In version 1, ",(0,t.jsx)(n.code,{children:"@kafkajs/confluent-schema-registry"})," only supported Avro schemas and\nthe API was very Avro specific. In version 2, support for JSON Schema and Protobuf\nwas added, which necessitated some changes in the public api."]}),"\n",(0,t.jsx)(n.p,{children:"We have tried to make these changes as unintrusive as we can, by making the vast\nmajority of changes backwards compatible. In fact, for Javascript users, the changes\nare completely backwards compatible for Avro schemas."}),"\n",(0,t.jsx)(n.p,{children:"For Typescript users, however, or if you are migrating from using Avro to using\none of the other schema types, there are a few things to keep in mind."}),"\n",(0,t.jsxs)(n.p,{children:["The main change is that the core ",(0,t.jsx)(n.code,{children:"Schema"})," type has changed from an Avro specific\nschema to a generic schema interface for all schema types. The old schema looked\nlike this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface AvroSchema {\n  name: string\n  namespace?: string\n  type: 'record'\n  fields: any[]\n  toBuffer(payload: object): Buffer\n  fromBuffer(buffer: Buffer, resolver?: Resolver, noCheck?: boolean): any\n  isValid(\n    payload: object,\n    opts?: { errorHook: (path: Array<string>, value: any, type?: any) => void },\n  ): boolean\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is still the case for Avro schemas, but for Protobuf or Json Schema, a\nmore generic schema type is used:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface Schema {\n  toBuffer(payload: object): Buffer\n  fromBuffer(buffer: Buffer, resolver?: Resolver, noCheck?: boolean): any\n  isValid(\n    payload: object,\n    opts?: { errorHook: (path: Array<string>, value: any, type?: any) => void },\n  ): boolean\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you have code that uses any of the Avro specific fields on the schema\n(for example returned by ",(0,t.jsx)(n.code,{children:"getSchema"}),"), you may need to first narrow the type\nto ",(0,t.jsx)(n.code,{children:"AvroSchema"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { AvroSchema, Schema } from '@kafkajs/confluent-schema-registry'\n\nfunction isAvroSchema(schema: AvroSchema | Schema): schema is AvroSchema {\n  return (schema as AvroSchema).name != null\n}\n\nconst schema = await registry.getSchema(registryId)\n\nif (isAvroSchema(schema)) {\n  // schema is now `AvroSchema`\n  const { name, namespace, type, fields } = schema\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"adapting-to-new-apis",children:"Adapting to new APIs"}),"\n",(0,t.jsxs)(n.p,{children:["This is ",(0,t.jsx)(n.strong,{children:"entirely optional"}),", as all the old APIs should be retained (with the above caveat\nabout the schema type), but if you want to adapt your code to the new API to make\nfuture migrations easier, these are the changes you would need to make."]}),"\n",(0,t.jsx)(n.h3,{id:"configuring-serialization-libraries",children:"Configuring serialization libraries"}),"\n",(0,t.jsxs)(n.p,{children:["In version 1, the client constructor took a second ",(0,t.jsx)(n.code,{children:"options"})," argument with\na single option ",(0,t.jsx)(n.code,{children:"forSchemaOptions"})," that was passed directly to\n",(0,t.jsx)(n.a,{href:"https://github.com/mtth/avsc/wiki/API#typeforschemaschema-opts",children:(0,t.jsx)(n.code,{children:"avsc.Type.forSchema"})}),"\nas the ",(0,t.jsx)(n.code,{children:"opts"})," argument."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const { SchemaRegistry } = require('@kafkajs/confluent-schema-registry')\n\nconst registry = new SchemaRegistry(\n  { host: 'http://localhost:8081' },\n  { forSchemaOptions: { noAnonymousTypes: true }}\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Since we now support multiple schema types, these options have been moved\none level into a schema type specific option without the ",(0,t.jsx)(n.code,{children:"forSchemaOptions"}),"\nkey:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const { SchemaRegistry, SchemaType } = require('@kafkajs/confluent-schema-registry')\n\nconst registry = new SchemaRegistry(\n  { host: 'http://localhost:8081' },\n  {\n    [SchemaType.AVRO]: { noAnonymousTypes: true },\n    \n    // This allows you to also pass options for Protobuf and JSON Schema\n    [SchemaType.JSON]: { strict: true }\n\n    [SchemaType.PROTOBUF]: { messageName: 'CustomMessage' }\n  }\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"./usage#schema-type-options",children:"Schema Type Options"})," for more information."]}),"\n",(0,t.jsx)(n.h3,{id:"registering-schemas",children:"Registering schemas"}),"\n",(0,t.jsxs)(n.p,{children:["In version 1, the schema type was implicitly Avro, so you would just pass in the\nschema from ",(0,t.jsx)(n.code,{children:"readAVSCAsync"})," directly:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const schema = await readAVSCAsync('path/to/schema.avsc')\nawait registry.register(schema)\n"})}),"\n",(0,t.jsx)(n.p,{children:"In version 2, there are two major changes:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"type"})," of the schema needs to be set to one of ",(0,t.jsx)(n.code,{children:"SchemaType"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"schema"})," itself is now a string, instead of an object."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["We call this new type a ",(0,t.jsx)(n.code,{children:"ConfluentSchema"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface ConfluentSchema {\n  type: SchemaType\n  schema: string\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const { SchemaType } = require('@kafkajs/confluent-schema-registry')\n\nconst schema = await readAVSCAsync('path/to/schema.avsc')\nconst schemaString = JSON.stringify(schema)\nawait registry.register({ type: SchemaType.AVRO, schema: schemaString })\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getting-registry-id-by-schema",children:"Getting registry id by schema"}),"\n",(0,t.jsxs)(n.p,{children:["Similar to ",(0,t.jsx)(n.code,{children:"register"}),", getting the registry id by schema used to take an\n",(0,t.jsx)(n.code,{children:"AvroSchema"}),", and now takes a ",(0,t.jsx)(n.code,{children:"ConfluentSchema"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Version 1:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const schema = await readAVSCAsync('path/to/schema.avsc')\nawait registry.getRegistryIdBySchema('subject', schema)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Version 2:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const schema = await readAVSCAsync('path/to/schema.avsc')\nconst schemaString = JSON.stringify(schema)\nawait registry.getRegistryIdBySchema('subject', { type: SchemaType.AVRO, schema: schemaString })\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>i});var a=s(6540);const t={},r=a.createContext(t);function c(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);
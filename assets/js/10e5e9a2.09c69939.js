"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[397],{138:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"advanced-usage","title":"Advanced Usage","description":"While typical usage is covered in Usage, Confluent Schema Registry also","source":"@site/../docs/advanced-usage.md","sourceDirName":".","slug":"/advanced-usage","permalink":"/confluent-schema-registry/docs/advanced-usage","draft":false,"unlisted":false,"editUrl":"https://github.com/kafkajs/confluent-schema-registry/edit/master/s/../docs/advanced-usage.md","tags":[],"version":"current","frontMatter":{"id":"advanced-usage","title":"Advanced Usage","sidebar_label":"Advanced Usage"},"sidebar":"docs","previous":{"title":"Usage","permalink":"/confluent-schema-registry/docs/usage"},"next":{"title":"Custom Types","permalink":"/confluent-schema-registry/docs/custom-types"}}');var a=t(4848),c=t(8453);const i={id:"advanced-usage",title:"Advanced Usage",sidebar_label:"Advanced Usage"},r=void 0,d={},o=[{value:"Get latest schema id by subject",id:"get-latest-schema-id-by-subject",level:2},{value:"Get schema id by subject and version",id:"get-schema-id-by-subject-and-version",level:2},{value:"Get schema id by schema",id:"get-schema-id-by-schema",level:2},{value:"Getting schema by schema id",id:"getting-schema-by-schema-id",level:2},{value:"Using custom middlewares",id:"using-custom-middlewares",level:2}];function l(e){const s={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(s.p,{children:["While typical usage is covered in ",(0,a.jsx)(s.a,{href:"./usage",children:"Usage"}),", Confluent Schema Registry also\nprovides functionality for more advanced usage."]}),"\n",(0,a.jsx)(s.h2,{id:"get-latest-schema-id-by-subject",children:"Get latest schema id by subject"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-js",children:"const subject = 'com.example.Simple'\nconst id = await registry.getLatestSchemaId(subject)\n"})}),"\n",(0,a.jsx)(s.h2,{id:"get-schema-id-by-subject-and-version",children:"Get schema id by subject and version"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-js",children:"const subject = 'com.example.Simple'\nconst version = 1\n\nconst id = await registry.getRegistryId(subject, version)\n"})}),"\n",(0,a.jsxs)(s.blockquote,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.em,{children:"Note:"})," Currently there is no way to list versions by subject."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"get-schema-id-by-schema",children:"Get schema id by schema"}),"\n",(0,a.jsx)(s.p,{children:"Returns the schema id if the schema has already been registered for the provided\nsubject."}),"\n",(0,a.jsxs)(s.p,{children:["If a matching schema does not exist for the subject, it throws a\n",(0,a.jsx)(s.code,{children:"ConfluentSchemaRegistryError"})]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-js",children:"const subject = 'com.example.Simple'\nconst schema = await avdlToAVSCAsync('path/to/protocol.avdl')\n\nconst id = await registry.getRegistryIdBySchema(subject, {\n  type: SchemaType.AVRO,\n  schema: JSON.stringify(schema),\n})\n"})}),"\n",(0,a.jsx)(s.h2,{id:"getting-schema-by-schema-id",children:"Getting schema by schema id"}),"\n",(0,a.jsx)(s.p,{children:"Normally Confluent Schema Registry keeps the schemas internally and don't require\nthe user to handle them to encode/decode data, but if you need to get a schema\nfrom the registry, you can do so by its schema id:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-js",children:"// See https://github.com/kafkajs/confluent-schema-registry/blob/master/src/%40types.ts#L30-L46\n// for a complete return type\nconst schema = await registry.getSchema(id)\n"})}),"\n",(0,a.jsx)(s.h2,{id:"using-custom-middlewares",children:"Using custom middlewares"}),"\n",(0,a.jsx)(s.p,{children:"The Schema Registry Client now supports adding custom mappersmith middlewares, providing flexibility to handle various use cases such as OAuth authentication or other custom request/response transformations."}),"\n",(0,a.jsx)(s.p,{children:"To use custom middlewares, include them when initializing the Schema Registry Client:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-ts",children:"import { Middleware } from 'mappersmith'\n\nconst customMiddleware: Middleware = jest.fn(() => {\n  return {\n    async request(request) {\n      return request.enhance({\n        headers: {\n          Authorization: 'Bearer Random',\n        },\n      })\n    },\n    async response(next) {\n      return next()\n    },\n  }\n})\n\nconst registry = new SchemaRegistry({\n  host: 'your_host',\n  middlewares: [customMiddleware],\n})\n"})})]})}function h(e={}){const{wrapper:s}={...(0,c.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>r});var n=t(6540);const a={},c=n.createContext(a);function i(e){const s=n.useContext(c);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(c.Provider,{value:s},e.children)}}}]);
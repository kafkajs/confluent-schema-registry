"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[931],{1237:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>r,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"usage","title":"Usage","description":"Typical usage consists of uploading one or more schemas to the registry, [encoding","source":"@site/../docs/usage.md","sourceDirName":".","slug":"/usage","permalink":"/confluent-schema-registry/docs/usage","draft":false,"unlisted":false,"editUrl":"https://github.com/kafkajs/confluent-schema-registry/edit/master/s/../docs/usage.md","tags":[],"version":"current","frontMatter":{"id":"usage","title":"Usage","sidebar_label":"Usage"},"sidebar":"docs","previous":{"title":"Introduction","permalink":"/confluent-schema-registry/docs/introduction"},"next":{"title":"Advanced Usage","permalink":"/confluent-schema-registry/docs/advanced-usage"}}');var a=s(4848),i=s(8453);const r={id:"usage",title:"Usage",sidebar_label:"Usage"},c=void 0,o={},h=[{value:"Creating the registry client",id:"creating-the-registry-client",level:2},{value:"Uploading schemas",id:"uploading-schemas",level:2},{value:"Avro",id:"avro",level:3},{value:"Subject",id:"subject",level:4},{value:"JSON Schema",id:"json-schema",level:3},{value:"Protobuf",id:"protobuf",level:3},{value:"Compatibility",id:"compatibility",level:3},{value:"Subjects",id:"subjects",level:3},{value:"Other schema types",id:"other-schema-types",level:4},{value:"Encoding data",id:"encoding-data",level:2},{value:"Decoding data",id:"decoding-data",level:2},{value:"Avro",id:"avro-1",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Retry",id:"retry",level:3},{value:"Basic auth",id:"basic-auth",level:3},{value:"HTTP Agent",id:"http-agent",level:3},{value:"Schema type options",id:"schema-type-options",level:3},{value:"Avro",id:"avro-2",level:4},{value:"Protobuf",id:"protobuf-1",level:4},{value:"JSON Schema",id:"json-schema-1",level:4}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Typical usage consists of ",(0,a.jsx)(n.a,{href:"#uploading-schemas",children:"uploading one or more schemas"})," to the registry, ",(0,a.jsx)(n.a,{href:"#encoding-data",children:"encoding\ndata"})," using the registered schemas, and/or ",(0,a.jsx)(n.a,{href:"#decoding-data",children:"decoding encoded data"})," by getting\nthe schemas from the registry."]}),"\n",(0,a.jsx)(n.h2,{id:"creating-the-registry-client",children:"Creating the registry client"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { SchemaRegistry } = require('@kafkajs/confluent-schema-registry')\n\nconst registry = new SchemaRegistry({ host: 'http://localhost:8081' })\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For more configuration options, ",(0,a.jsx)(n.a,{href:"#configuration",children:"see configuration"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"uploading-schemas",children:"Uploading schemas"}),"\n",(0,a.jsxs)(n.p,{children:["The schemas can be registered with the schema registry using\n",(0,a.jsx)(n.code,{children:"registry.register({ type: SchemaType, schema: string })"}),", which resolves to an object containing the\nschema id. This schema id is later ",(0,a.jsx)(n.a,{href:"#encoding-data",children:"used when encoding"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const schema = {\n  type: SchemaType.AVRO | SchemaType.JSON | SchemaType.PROTOBUF,\n  schema: "string"\n}\n\nconst options = {\n  subject: "string"\n}\n\nawait registry.register(schema, options)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"avro",children:"Avro"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const schema = `\n  {\n    "type": "record",\n    "name": "RandomTest",\n    "namespace": "examples",\n    "fields": [{ "type": "string", "name": "fullName" }]\n  }\n`\nconst { id } = await registry.register({ type: SchemaType.AVRO, schema })\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To simplify working with Avro schemas and integrating with existing tooling,\nsome utility functions are available. Schemas can be defined in either ",(0,a.jsx)(n.code,{children:"AVSC"}),"\nor ",(0,a.jsx)(n.code,{children:"AVDL"})," format, and are read using ",(0,a.jsx)(n.code,{children:"readAVSCAsync"})," and ",(0,a.jsx)(n.code,{children:"avdlToAVSCAsync"}),"\nrespectively."]}),"\n",(0,a.jsxs)(n.p,{children:["Note that these functions return objects rather than strings, but they can\nbe passed directly to ",(0,a.jsx)(n.code,{children:"register"})," as the ",(0,a.jsx)(n.code,{children:"schema"})," argument and will be\nstringified internally."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { SchemaType, readAVSCAsync, avdlToAVSCAsync } = require('@kafkajs/confluent-schema-registry')\n\n// From an avsc file\nconst schema = await readAVSCAsync('path/to/schema.avsc')\nconst { id } = await registry.register({ type: SchemaType.AVRO, schema }) // { id: 2 }\n\n// From an avdl file\nconst schema = await avdlToAVSCAsync('path/to/protocol.avdl')\nconst { id } = await registry.register({ type: SchemaType.AVRO, schema }) // { id: 3 }\n"})}),"\n",(0,a.jsx)(n.h4,{id:"subject",children:"Subject"}),"\n",(0,a.jsxs)(n.p,{children:["For Avro schemas, the subject is automatically inferred from the schema if\n",(0,a.jsx)(n.code,{children:"options.subject"})," is not set."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"#subjects",children:"Subjects"})," for more information on subjects"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"json-schema",children:"JSON Schema"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const { SchemaType } = require(\'@kafkajs/confluent-schema-registry\')\n\nconst schema = `\n  {\n    "definitions" : {\n      "record:examples.Person" : {\n        "type" : "object",\n        "required" : [ "fullName" ],\n        "additionalProperties" : false,\n        "properties" : {\n          "fullName" : {\n            "type" : "string"\n          }\n        }\n      }\n    },\n    "$ref" : "#/definitions/record:examples.Person"\n  }\n`\nconst { id } = await registry.register({ type: SchemaType.JSON, schema })\n'})}),"\n",(0,a.jsx)(n.h3,{id:"protobuf",children:"Protobuf"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { SchemaType } = require('@kafkajs/confluent-schema-registry')\n\nconst schema = `\n  package examples;\n  message RandomTest {\n    required string fullName = 1;\n  }\n`\nconst { id } = await registry.register({ type: SchemaType.PROTOBUF, schema })\n"})}),"\n",(0,a.jsx)(n.h3,{id:"compatibility",children:"Compatibility"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"https://docs.confluent.io/current/schema-registry/avro.html#compatibility-types",children:"compatibility"})," of the schema will be whatever the global default is (typically ",(0,a.jsx)(n.code,{children:"BACKWARD"}),").\nIt's possible to override this for the specific subject by setting it like so:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const {\n  COMPATIBILITY: { NONE },\n} = require('@kafkajs/confluent-schema-registry')\nawait registry.register(schema, { compatibility: NONE })\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"NOTE:"}),"\nIf the subject already has an overridden compatibility setting and it's different,\nthe client will throw and error (",(0,a.jsx)(n.code,{children:"ConfluentSchemaRegistryCompatibilityError"}),")"]}),"\n",(0,a.jsx)(n.h3,{id:"subjects",children:"Subjects"}),"\n",(0,a.jsxs)(n.p,{children:["Each schema is registered under a ",(0,a.jsx)(n.a,{href:"https://docs.confluent.io/current/schema-registry/serializer-formatter.html#sr-avro-subject-name-strategy",children:"subject"}),".\nIn Avro, this subject is generated by concatenating the schema namespace and the schema name\nwith a separator. For example, the following schema would get the subject ",(0,a.jsx)(n.code,{children:"com.example.Simple"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-avdl",children:'@namespace("com.example")\nprotocol SimpleProto {\n  record Simple {\n    string foo;\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"registry.register"})," accepts a ",(0,a.jsx)(n.code,{children:"subject"})," option to override the subject entirely:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"await registry.register(schema, { subject: 'my-fixed-subject' })\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If you just want to change the separator used when automatically creating the subject, use\nthe ",(0,a.jsx)(n.code,{children:"separator"})," option:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// This would result in \"com.example-Simple\"\nawait registry.register(schema, { separator: '-' })\n"})}),"\n",(0,a.jsx)(n.h4,{id:"other-schema-types",children:"Other schema types"}),"\n",(0,a.jsxs)(n.p,{children:["For non-Avro schema types, ",(0,a.jsx)(n.code,{children:"subject"})," is required and the method will throw if not provided."]}),"\n",(0,a.jsx)(n.h2,{id:"encoding-data",children:"Encoding data"}),"\n",(0,a.jsxs)(n.p,{children:["To encode data, call ",(0,a.jsx)(n.code,{children:"registry.encode"})," with the schema id and the payload to encode."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const payload = { full_name: 'John Doe' }\nawait registry.encode(id, payload)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"decoding-data",children:"Decoding data"}),"\n",(0,a.jsxs)(n.p,{children:["The encoded payload contains the schema id of the schema used to decode it,\nso to decode, simply call ",(0,a.jsx)(n.code,{children:"registry.decode"})," with the encoded payload. The\ncorresponding schema will be downloaded from the registry if needed in order\nto decode the payload."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const payload = await registry.decode(buffer)\n// { full_name: 'John Doe' }\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"registry.decode"})," has an optional second ",(0,a.jsx)(n.code,{children:"options"})," argument with options\nspecific to each schema type."]}),"\n",(0,a.jsx)(n.h3,{id:"avro-1",children:"Avro"}),"\n",(0,a.jsx)(n.p,{children:"With Avro you can specify a specific reader schema to use to decode the\nmessage, rather than using the schema registered in the registry. This can\nbe useful if you need a projection that is different from the writer schema,\nor if you want to decode a message with a different version than was\nused to encode the message."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import avro from 'avsc'\nimport { readAVSCAsync } from '@kafkajs/confluent-schema-registry'\n\nconst readerSchema = await readAVSCAsync('path/to/protocol.avdl')\n\nconst payload = await registry.decode(buffer, {\n  [SchemaType.AVRO]: { readerSchema }\n})\n"})}),"\n",(0,a.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,a.jsx)(n.h3,{id:"retry",children:"Retry"}),"\n",(0,a.jsxs)(n.p,{children:["By default, all ",(0,a.jsx)(n.code,{children:"GET"})," requests will retry three times in case of failure. If you want to tweak this config you can do:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const registry = new SchemaRegistry({\n  host: 'http://localhost:8081',\n  retry: {\n    maxRetryTimeInSecs: 5,\n    initialRetryTimeInSecs: 0.1,\n    factor: 0.2, // randomization factor\n    multiplier: 2, // exponential factor\n    retries: 3, // max retries\n  },\n})\n"})}),"\n",(0,a.jsx)(n.h3,{id:"basic-auth",children:"Basic auth"}),"\n",(0,a.jsx)(n.p,{children:"It's also possible to configure basic auth:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const registry = new SchemaRegistry({\n  host: 'http://localhost:8081',\n  auth: {\n    username: '***',\n    password: '***',\n  },\n})\n"})}),"\n",(0,a.jsx)(n.h3,{id:"http-agent",children:"HTTP Agent"}),"\n",(0,a.jsxs)(n.p,{children:["Configuring the behavior of the HTTP requests towards the schema registry API\ncan be done by passing in an instance of an ",(0,a.jsx)(n.a,{href:"https://nodejs.org/api/https.html#https_class_https_agent",children:"Agent"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { Agent } from 'http'\n\nconst agent = new Agent({ keepAlive: true })\nconst registry = new SchemaRegistry({\n  host: 'http://localhost:8081',\n  agent\n})\n"})}),"\n",(0,a.jsx)(n.h3,{id:"schema-type-options",children:"Schema type options"}),"\n",(0,a.jsxs)(n.p,{children:["The second argument to the ",(0,a.jsx)(n.code,{children:"SchemaRegistry"})," constructor is an object with keys for each ",(0,a.jsx)(n.code,{children:"SchemaType"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"avro-2",children:"Avro"}),"\n",(0,a.jsxs)(n.p,{children:["The Avro schema type options are passed directly to\n",(0,a.jsxs)(n.a,{href:"https://github.com/mtth/avsc/wiki/API#typeforschemaschema-opts",children:[(0,a.jsx)(n.code,{children:"avsc.Type.forSchema"})," as the ",(0,a.jsx)(n.code,{children:"opts"})," argument"]}),".\nFor example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import {\xa0SchemaRegistry, SchemaType } from '@kafkajs/confluent-schema-registry'\n\nconst options = {\n  [SchemaType.AVRO]: {\n    logicalTypes: { decimal: DecimalType }\n  }\n}\n\nconst registry = new SchemaRegistry({ host: 'http://localhost:8081' }, options)\n"})}),"\n",(0,a.jsx)(n.h4,{id:"protobuf-1",children:"Protobuf"}),"\n",(0,a.jsxs)(n.p,{children:["The only available option is ",(0,a.jsx)(n.code,{children:"messageName"}),", which is used to select which message\nin a schema containing multiple messages to use for encoding/decoding the payload.\nIf omitted, the first message type in the schema is used."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const options = {\n  [SchemaType.PROTOBUF]: {\n    messageName: 'CustomMessage'\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"json-schema-1",children:"JSON Schema"}),"\n",(0,a.jsxs)(n.p,{children:["The JSON Schema schema type options are passed to the ",(0,a.jsx)(n.a,{href:"https://ajv.js.org/options.html",children:"Ajv constructor"}),".\nFor example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const options = {\n  [SchemaType.JSON]: {\n    strict: true\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Alternatively, you can provide a custom Ajv instance using the ",(0,a.jsx)(n.code,{children:"ajvInstance"})," option. This can be useful if you\nneed to configure Ajv outside of what the constructor parameters allow."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const options = {\n  [SchemaType.JSON]: {\n    ajvInstance: new Ajv()\n  }\n}\n"})})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(6540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);